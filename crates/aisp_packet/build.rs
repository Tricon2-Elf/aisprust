use regex::Regex;
use std::{collections::BTreeSet, env, fs, path::PathBuf};
use walkdir::WalkDir;

use syn::{Attribute, Item, Meta};

fn main() {
    println!("cargo::rerun-if-changed=build.rs");

    let out_dir = env::var("OUT_DIR").unwrap();

    let mut manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_PATH").unwrap());
    manifest_dir.pop();

    let packet_dir = manifest_dir.join("src/packets");
    let src_mod_file = packet_dir.join("mod.rs");
    let out_mod_file = packet_dir.join("src/packets/mod.rs");

    println!("cargo:rerun-if-changed=src/packets");

    let struct_regex = Regex::new(r"(?s)((?:#\[.*?\]\s*)+)(pub struct\s+(\w+)[^{]*\{.*?\})")
        .expect("failed to compile regex");
    let packet_id_regex = Regex::new(r"packet\((\w+)\)").expect("failed to compile regex");
    let struct_name = Regex::new(r"struct\s+([^\s]+)\s*\{").expect("failed to compile regex");

    let dir_iter = WalkDir::new(&packet_dir)
        .into_iter()
        .filter_map(Result::ok)
        .filter(|e| e.file_type().is_file() && e.path().extension().is_some_and(|s| s == "rs"));

    let mut packet_map = BTreeSet::new();
    let mut modules = BTreeSet::new();

    for rust_file in dir_iter {
        let file_path = rust_file.path();
        let cur_mod_name = file_path
            .file_stem()
            .and_then(|s| s.to_str())
            .expect("file name 2");

        if cur_mod_name.starts_with("mod") {
            continue;
        }

        // println!("cargo::rerun-if-changed=src/packets/{}.rs", cur_mod_name);
        modules.insert(cur_mod_name.to_string());

        let file_data = fs::read_to_string(file_path).expect("Failed to read");

        let syntax = syn::parse_file(&file_data)
            .expect(&format!("failed to parse rust file [{}]", cur_mod_name));

        for item in syntax.items {
            if let syn::Item::Struct(struct_item) = item {
                let is_packet: bool = {
                    let mut res = false;
                    for attr in &struct_item.attrs {
                        match &attr.meta {
                            Meta::List(pat) => {
                                if pat.path.is_ident("packet") {
                                    res = true;
                                    break;
                                }
                            }
                            _ => continue,
                        }
                    }
                    res
                };
                // Only keep structs that have #[packet(...)]
                if is_packet {
                    let name = struct_item.ident.to_string();
                    packet_map.insert(format!("{cur_mod_name}::{name}"));
                }
            }
        }
        // for struct_entry in struct_regex.find_iter(&file_data) {
        //     let name = struct_name
        //         .captures(struct_entry.as_str())
        //         .and_then(|s| s.get(1))
        //         .map(|s| s.as_str())
        //         .unwrap_or_default();
        //
        //     if name.is_empty() {
        //         continue;
        //     }
        //
        //     let packet_id = match packet_id_regex.captures(struct_entry.as_str()) {
        //         Some(s) => {
        //             let num_str = s.get(1).map_or("0", |m| m.as_str());
        //
        //             if let Some(hex) = num_str
        //                 .strip_prefix("0x")
        //                 .or_else(|| num_str.strip_prefix("0X"))
        //             {
        //                 u64::from_str_radix(hex, 16).expect("Failed to parse hex int")
        //             } else {
        //                 num_str.parse::<u64>().expect("Failed to parse int")
        //             }
        //         }
        //         None => continue, // ignore non packets
        //     };
        //
        //     packet_map.insert(format!("{}::{}", cur_mod_name, name));
        // }
    }

    let mut mod_contents = String::new();
    mod_contents.push_str(
        "// generated by build.rs, do not edit
//

use aisp_packet_macros::packet_register;

use crate::deserializer;
use crate::error::ParseError;
use crate::serializer;

pub trait Packet {
    const ID: u16;
}

",
    );

    for module in &modules {
        mod_contents.push_str(&format!("pub mod {};\n", module));
    }

    mod_contents.push_str("\npacket_register! {\n");
    for pkt in &packet_map {
        mod_contents.push_str(&format!("    {pkt},\n"));
    }
    mod_contents.push_str("}\n");
    fs::write(&src_mod_file, &mod_contents).expect("failed to write mod.rs");
    // fs::write(&out_mod_file, &mod_contents).expect("failed to write mod.rs");
}
